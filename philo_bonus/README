WHEN A PROCESS IS "KILLED" THE SEMAPHORE ARE AUTOMATICALLY CLOSES,
BUT NOT UNLINK

APPARETNLY IF YOU UNLINK A SEMAPHORE, IT WILL WAIT UNTIL EVERY SEMAPHORE IS CLOSES BEFORE DELETING. THE NAME STILL "DOESN'T EXIST" : if you sem_open with the same sem_name, it will be a completly new semaphore.

Philo bonus idea:
- Every philosopher must be a process

When creating philosopher (processes)
-create one process
- SEND SIGSTOP signal
-> loop
when every process is created :
send SIGCONTINUE to all process

PHILO ROUTINE (process not shared memory)
-? Wait until every philo is created (simulation start)
- Death checker should be a thread (one thread per philosopher because one thread would not now when another philosopher die)
    Same thing for main process, connot read process state (philo state) without pipe
-Meal checker (Semaphore contenat nombre de repas total reduit un par un par les philo)
Meal 
- eat, sleep, think while monitored by th thread
loop
- exit process properly

MAIN PROCESS:
- Init struct ?
- Fork every process and STOPTHEM
- SIGCONTINUE Every process 
>> Create thread that wait until a philo die to finish printing

HOW TO MONITOR
- WAIT CHILD
- DELETE Semaphore
- EXIT PHILO